# 浅析ST表

> 最近不知为何一直在写倍增……

ST表是专门处理RMQ（静态查询区间最大值）问题的一种数据结构。

它的速度非常快。可以做到$O(nlogn)$的时间建表，$O(1)$的时间查询。

相对于线段树之类的，它查询的速度不知快了几倍。

不过，它也有个缺陷：只能解决RMQ问题。~~那好像ST表有点太垃圾了~~

其实ST表在某些方面也是能应用的。~~基于一些神奇的特性~~

## 倍增

先来讲讲倍增。

看到倍增两个字，你想到了什么？$2^k$！

好。你猜对了。倍增就是跟$2$的次幂有关的。

打个比方：

有个人，开着一架飞机，在一些线性的飞机场从左往右飞。比如：

$$air_1\quad air_2\quad air_3\quad air_4\quad air_5\quad air_6\quad air_7\quad air_8\quad air_9$$

然而，这个人脱离社会，什么现代化的东西都不会用~~那他怎么会开飞机~~。

他根本不知道他起飞和降落的飞机场之间距离是多少。

于是，他拿着纸笔，去打表了……

首先，他从$air_1$起飞，到了$air_2$，他记录下这个$air_1$到$air_2$的距离为$1$……

以此类推，他最终得出了每个机场分别到其他机场需要多少距离。

那么，他一共记下了$9\times 9=81$个数据。飞机场少还好，如果多了，不仅他自己忙不过来，而且表也打不完……

所以就产生了一个办法：我们只记录从某个机场出发飞$2^k$距离的终点机场。

当然，这数据一下子小多了。用表的时候，只要先找到终点机场附近的一个机场（在起点机场的表上），继续沿着这个机场找下去，直到找到为止。

比如：$air_2$到$air_9$。

我们可以先从$air_2$找到$air_6$，然后再找到$air_8$，最后再找到$air_9$。

这样预处理复杂度为$O(nlogn)$，查询复杂度为$O(logn)$，在预处理和查询的复杂度上找到了一个平衡（相对于预处理复杂度为$O(n^2)$和查询复杂度为$O(n)$的算法来说）。

不过，这里就只是说明一下倍增的思想而已，也只是说明一下倍增的方便。

另外备注一句：**倍增一般是从大到小查询的**，这在刚刚所举的例子中也有体现。

很明显，从高位到低位查询肯定会方便很多。

不过ST表的倍增查询比较特殊，是$O(1)$的，与这里介绍的略有不同，但核心思想是一样的。

## ST表

懂了倍增，ST表也是挺简单的了。

这里以静态求区间最大值为例。

我们把区间分成许多块，每块的长度为$2^k$。区间开始的位置可以随便取。

首先，我们建个表：这里用的是DP的思想。每一块最大值都是两个子块的最大值。

不过，为了快一点，最好要把$\lfloor log_2(n)\rfloor$全部预处理出来。

下面给出建表的代码：

```pascal
procedure build(n:longint);
begin
  log_2[1]:=0;
  for i:=2 to n do             //预处理log2(n)
    log_2[i]:=log_2[i div 2]+1;
  for i:=1 to n do             //一个数的最大值就是它本身
    f[i,0]:=a[i];
  for j:=1 to log_2[n] do      //枚举区间长度2^j
    for i:=1 to n+1-1 shl i do //枚举区间开始位置
	  f[i,j]:=max(f[i,j-1],f[i+1 shl (j-1),j-1]);
end;
```

```c++
void build(int n);
{
    log_2[1]=0;
	for (int i=2;i<=n;i++)     //预处理log2(n)
	{
	    log_2[i]=log_2[i/2]+1;
	}
    for (int i=1;1<=n;i++)     //一个数的最大值就是它本身
	{
	    f[i,0]=a[i];
	}
	for (int j=1;j<=log_2[n];j++)//枚举区间长度2^j
	{
	    for (int i=1;i<=n+1-(1<<j);i++)//枚举区间开始位置
		{
		    f[i,j]=max(f[i,j-1],f[i+(1<<j-1),j-1]);
		}
	}
}
```

我们有了这些信息有什么用呢？怎么实现$O(1)$查询呢？

举个例子：计算从$a_2$到$a_{10}$的最大值。一共有$9$个数。

我们知道，$\lfloor log_2(9)\rfloor=3$。所以，我们只要查询从$a_2$开始的$2^3$个数的最大值和$a_{10}$往前的$2^3$个数的最大值再取最大值就行了。

~~似乎有点绕~~

我们知道，只用从开始的一个区间，是不可能完全覆盖整个区间的~~很明显长度不可能总是$2^k$~~。

所以，要再用倒着向前的一个区间，两个区间互相覆盖~~求最值并没有影响~~，才能保证得出正确的答案。

超级简洁的代码：

```pascal
function query(l,r:longint):longint;
begin
  exit(max(f[l,log_2[r-l+1]],f[r-1 shl log_2[r-l+1]+1,log_2[r-l+1]]);
end;
```

```c++
int query(int l,int r);
{
    return max(f[l,log_2[r-l+1]],f[r-(1<<log_2[r-l+1])+1,log_2[r-l+1]]);
}
```

总结一下，其实ST表的代码挺简洁的，也很好学。只要搞懂就行了。

> 其他：
>
> 有很多人说ST表除了解决RMQ和LCA的时候代码短就没什么用了……
>
> 其实根据ST表的特点，我们可以做到$O(logn)$在表末插入元素~~不过只要数组下标允许也可以在表首插入~~